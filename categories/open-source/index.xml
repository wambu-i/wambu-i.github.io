
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Open-Source on Wambui Karuga</title>
   <link>https://www.karuga.org/categories/open-source/</link>
   <description>Recent content in Open-Source on Wambui Karuga</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <lastBuildDate>Sun, 19 Jul 2020 20:47:44 +0300</lastBuildDate>
   
       <atom:link href="https://www.karuga.org/categories/open-source/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>Happy Hour Wednesdays: Arrays Part II</title>
       <link>https://www.karuga.org/posts/happy-hour-ii/</link>
       <pubDate>Mon, 16 Nov 2020 09:47:30 +0300</pubDate>
       
       <guid>https://www.karuga.org/posts/happy-hour-ii/</guid>
       <description>&lt;p&gt;As with our &lt;a href=&#34;https://www.karuga.org/posts/happy-hour-i/&#34;&gt;first&lt;/a&gt; post, this post continues to review the recently concluded #HappyHourWednesdays interview questions of
arrays.&lt;br&gt;
The last two array questions are as follows:&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Product of Array Except Self&lt;/strong&gt;&lt;br&gt;
This challenge from &lt;a href=&#34;https://leetcode.com/problems/product-of-array-except-self/&#34;&gt;LeetCode&lt;/a&gt; is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given an array nums of n integers where n &amp;gt; 1,  return an array output
such that output[i] is equal to the product of all the elements of nums
except nums[i].
It&#39;s guaranteed that the product of the elements of any prefix or suffix
of the array (including the whole array) fits in a 32 bit integer.
Note: Please solve it without division and in O(n).
Could you solve it with constant space complexity? (The output array does
not count as extra space for the purpose of space complexity analysis.)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;``
This challenge has a very simple solution using division - find the product of all the elements in the given array, then for each of the elements of the array, divide the product by &lt;code&gt;x&lt;/code&gt; to find the &lt;code&gt;product of array except self&lt;/code&gt;. However, the challenge explicitly forbids us from using division and therefore another approach is needed.&lt;/p&gt;
&lt;p&gt;Another solution will be to find the product of all the elements before the given index and multiply it by the product of all the elements that occur after the given index.&lt;br&gt;
This solution can be written as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using namespace std;
public:
vector&amp;lt;int&amp;gt; productExceptSelf(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    int size = nums.size();
    vector&amp;lt;int&amp;gt; left(size, 1);
    vector&amp;lt;int&amp;gt; right(size, 1);
    vector&amp;lt;int&amp;gt; result(size, 0);
       
    for (auto i = 1; i &amp;lt; size; i++) {
        left[i] = left[i - 1] * nums[i - 1];
    }
       
    for (auto i = size - 2; i &amp;gt;= 0; i--) {
        right[i] = nums[i + 1] * right[i + 1];
    }
       
    for (auto i = 0; i &amp;lt; size; i++) {
        result[i] = left[i] * right[i];
    }
       
    return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This solution iterates over the two parts of the array, and multiplies the results to produce the solution.&lt;br&gt;
This algorithm runs in &lt;em&gt;O(n)&lt;/em&gt; time where n is the size of the input array and has &lt;em&gt;O(n)&lt;/em&gt; space complexity used by the three new arrays we&amp;rsquo;re using to keep track of the left, right and final elements.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Container with Most Water&lt;/strong&gt;&lt;br&gt;
This challenge is also from &lt;a href=&#34;https://leetcode.com/problems/container-with-most-water/&#34;&gt;LeetCode&lt;/a&gt; and is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given n non-negative integers a1, a2, ..., an , where each represents a
point at coordinate (i, ai). n vertical lines are drawn such that the two
endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which,
together with the x-axis forms a container, such that the container
contains the most water.
Notice that you may not slant the container.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This challenge is looking for the maximum area that can be formed between the vertical lines using the shorter line as length and the distance between the lines as the
width of the rectangle.
As with most of the array questions, this challenge can be solved using &lt;strong&gt;brute force&lt;/strong&gt; by iterating over the areas of every possible pair of the lines and picking the maximum
area out of those. However this is not the most efficient solution as it will produce an algorithm with a runtime of &lt;em&gt;(O^n2)&lt;/em&gt; which means that the solution will take longer for larger inputs.&lt;/p&gt;
&lt;p&gt;To optimize the solution, we&amp;rsquo;ll consider that the area is always limited by the height of the shorter line as the maximum height the water can be at will always be the height of the shorter line. Further more, the area produced will increase as the lines grow farther from each other.&lt;br&gt;
With this in mind, we can design a solution that works with this constraints using two pointers. One of these pointers will start at the beginning while the other one will start at the end of the array holding the lengths. These two pointers will then be used to iterate over the array as they start from different ends of the array. In each loop of the iteration, we&amp;rsquo;ll keep the maximum area found, updating it with the current area if it is larger than what was previously stored. At the end of each loop we&amp;rsquo;ll advance the pointer which points at the shorter line forward.&lt;br&gt;
This solution can be written as follows in C++:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using namespace std;
int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) {
    auto size = height.size();
    int first = 0;
    int last = size - 1;
    int max = 0;
    int curr;

    while (first &amp;lt; last) {
            curr = (last - first) * ((height[first] &amp;lt; height[last]) ? height[first] : height[last]);
            max =  curr &amp;gt; max ? curr: max;
            if (height[first] &amp;lt; height[last])
                    first++;
            else
                    last--;
    }

    return max;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This produces an algorithm with a time complexity of &lt;em&gt;O(n)&lt;/em&gt; as it solves the challenge in a single pass with a space complexity of &lt;em&gt;O(1)&lt;/em&gt; as no extra space has been allocated.&lt;/p&gt;
&lt;p&gt;With that, we come to the end of our array series.&lt;br&gt;
Here are some things to keep in mind when solving for arrays:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There is almost &lt;strong&gt;always a brute-force solution&lt;/strong&gt; to questions on arrays that includes iterating over the array/arrays. The most efficient solution is usually found by improving on this brute-force implementation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Know your array libraries!&lt;/strong&gt; Most programming languages have libraries that provide various array operations and algorithms. Being familiar with the library in your language of choice will often save you time from having to implement certain procedures from scratch.&lt;/li&gt;
&lt;li&gt;Be comfortable with writing solutions to problems that involve &lt;strong&gt;subarrays&lt;/strong&gt;!&lt;/li&gt;
&lt;li&gt;Some operations on arrays are expensive due to the inherent design of arrays, so always keep in mind how much time each operation might take especially for large inputs. For example, inserting an element from the beginning of an array is slower than inserting it from the end.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Always solve for when the array is empty first!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That&amp;rsquo;s it for arrays, and happy coding!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
     </item>
   
     <item>
       <title>Happy Hour Wednesdays: Arrays Part I</title>
       <link>https://www.karuga.org/posts/happy-hour-i/</link>
       <pubDate>Mon, 02 Nov 2020 09:07:47 +0300</pubDate>
       
       <guid>https://www.karuga.org/posts/happy-hour-i/</guid>
       <description>&lt;p&gt;As a community, we participate in our &lt;strong&gt;#HappyHourWednesdays&lt;/strong&gt; to get better at our technical interviewing skills.&lt;br&gt;
We do this by reviewing some of the most common data structures and algorithms and solving problems similar to those that are becoming increasingly  common during
the interviewing process. For the past couple of weeks, we&amp;rsquo;ve been going through one of the simplest data structure - the Array. This post will go through the questions
we&amp;rsquo;ve seen so far and offer explanations on the best solution to the challenges.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Two Sum&lt;/strong&gt;&lt;br&gt;
This was our first Array challenge from &lt;a href=&#34;https://leetcode.com/problems/two-sum/&#34;&gt;LeetCode&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given an array of integers nums and an integer target, return indices of
the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may
not use the same element twice. You can return the answer in any order.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With most array questions, there is usually a naive solution that includes looping through most elements once or twice. For this particular challenge, the brute force
solution would be to iterate through each element to see if there&amp;rsquo;s another value in the array that equals to the target when subtracted from it. This, however, provides
a solution with &lt;em&gt;O(n^2)&lt;/em&gt; time complexity which will make the solution inefficient as the imput array increases in size.&lt;/p&gt;
&lt;p&gt;To improve our time complexity, we&amp;rsquo;ll need a more efficient solution. One way to improve our solution is to keep track of complements of seen items in a hashmap such that when the
complement stored is found in the existing array, we can return the indices at once.
This means that we&amp;rsquo;ll only iterate through the array once, with each iteration including a check in the hashmap to see if its complement has already been seen before and stored. This reduces our run time complexity to &lt;em&gt;O(n)&lt;/em&gt; as we&amp;rsquo;ll only iterate through the array once. Our space complexity, however, increases to &lt;em&gt;O(n)&lt;/em&gt; due to the introduction of the hashmap (since the hashmap would only be able to store at most &lt;em&gt;n&lt;/em&gt; items - the original size of the array).&lt;/p&gt;
&lt;p&gt;This solution can be implemented as below in C++:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using namespace std;

vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        map&amp;lt;int, int&amp;gt; seen;
        auto size = nums.size();
        std::vector&amp;lt;int&amp;gt; result;
        int sum;

        for (auto i = 0; i &amp;lt; size; i++) {
                sum = target - nums[i];
                auto s = seen.find(sum);
                if (s != seen.end()) {
                        result.push_back(i);
                        result.push_back(s-&amp;gt;second);
                }
                seen.emplace(nums[i], i);
        }
           
    return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Best Time to Buy and Sell Stock&lt;/strong&gt;&lt;br&gt;
This challenge is also from &lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&#34;&gt;LeetCode&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Say you have an array for which the ith element is the price of a given
stock on day *i*. If you were only permitted to complete at most one
transaction (i.e., buy one and sell one share of the stock), design an
algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This challenge
As with the previous challenge, this problem has a brute force solution that includes iterating over the items from one end twice (the inner loops starts from &lt;em&gt;i + 1&lt;/em&gt;) while
keeping track of the maximum difference seen up to that point. Once both loops complete, the stored difference should be the maximum profit that can be achieved. This solution will have a time complexity of &lt;em&gt;O(n^2)&lt;/em&gt; as it has two loops iterating over the array.&lt;/p&gt;
&lt;p&gt;To improve this solution, we&amp;rsquo;ll employ one loop that iterates over the array while keeping track of the largest differemce seen so far followed by the smallest price in the array. This enables us to see the largest deep as the loop progresses. At the end of the loop, the largest difference will be stored and returned.&lt;br&gt;
This improves the run time complexity to &lt;em&gt;O(n)&lt;/em&gt; as only a single loop is needed for the array with a space complexity of &lt;em&gt;O(1)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This solution can be implemented as below in C++:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using namespace std;

int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {
        auto size = prices.size();
        int min = INT_MAX;
        int max = 0;
           
        for (auto i = 0; i &amp;lt; size; i++) {
                if (prices[i] &amp;lt; min) {
                        min = prices[i];
                }
                else if (prices[i] - min &amp;gt; max) {
                        max = prices[i] - min;
                }
        }
        return max;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;From these two examples, it&amp;rsquo;s clear that most array questions can be solved through brute force solutions which lead to pretty inefficient solutions. Improving on these solutions can lead to a more efficient solution in both space and time complexities.&lt;br&gt;
As &lt;strong&gt;#HappyHourWednesday&lt;/strong&gt; continues, we hope that going over these challenges greatly improves our ability to come up with efficient solutions during interviews.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>An Overview of Open Source Communities</title>
       <link>https://www.karuga.org/posts/opensource-overview/</link>
       <pubDate>Sun, 19 Jul 2020 20:47:44 +0300</pubDate>
       
       <guid>https://www.karuga.org/posts/opensource-overview/</guid>
       <description>&lt;p&gt;Open source projects usually employ unique collaborative processes and methods to work on a shared codebase or project for team members or individual contributors to ensure cohesive project advancement. To achieve this, the open source community has identified key aspects of managing such communities that ensure proper collaboration.&lt;/p&gt;
&lt;h2 id=&#34;management-of-open-source-communities&#34;&gt;Management of Open Source Communities&lt;/h2&gt;
&lt;p&gt;Each open source project usually creates its own structure, with some common aspects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;People&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each open source community will have a few key people to drive forward the development of the project in the right direction. The leader of the project is usually the original author of the software or some designated by them and usually has the final say over decision-making in the project. For example, in the Linux kernel, Linus Torvalds, the original author, is still actively involved in development and controls every release of the kernel.&lt;br&gt;
Sometimes, project leaders will usually handover administration of the project to a technical steering committee or foundation that acts as the governing body of the project. &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt; is an example of such a project - with it being formerly managed by the Node.js Foundation, which has evolved to the current OpenJS Foundation.&lt;/p&gt;
&lt;p&gt;In large communities, the project might by divided into specific parts that are overseen by experienced developers known as maintainers. The maintainers usually oversee development of their components of the project and will usually be the final stop before code reaches the leaders.&lt;br&gt;
Other than the maintainers, there are also regular and irregular contributors to the projects. Regular and reliable contributors can be given special privileges in the project and are usually referred to as &amp;ldquo;committers&amp;rdquo; or &amp;ldquo;someone with commit rights&amp;rdquo;. These are generally developers who&amp;rsquo;ve regularly contributed high quality work to these projects and can be trusted with the ability to merge their own code. On the other hand, irregular contributors generally contribute infrequently to their preferred projects and do not have any special privileges.&lt;/p&gt;
&lt;p&gt;The Linux kernel, for example, is divided into specific subsystems that handle different aspects of the kernel. Each subsystem has a maintainer who will submit work in their subsystem to Linus for final review and inclusion in kernel releases. In particularly large subsystems, the subsystem is usually divided into smaller components or communities which will in turn have their specific maintainers. Individual contributors will send their work to be reviewed by these maintainers who will propagate accepted changes up the maintainer ladder until the changes get to Linus.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hosting/Tracking Infrastructure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each open source community will have a mechanism for tracking ongoing work, issues and documentation for their projects. Over the past couple of years, GitHub has become the leading hosting service for open source projects. GitHub and GitLab both leverage the Git version control system to manage development of shared projects. On GitHub and GitLab, communities have access to pull requests, reviews and issue trackers that are used to keep the development process sane.&lt;/p&gt;
&lt;p&gt;An example of a GitHub focused open source project is React. All work on React happens on GitHub, with any one being able to create an &lt;a href=&#34;https://github.com/facebook/react/issues&#34;&gt;issue&lt;/a&gt; on the public issue tracker. Pull requests are usually submitted to address opened issues which can undergo review by the core React team and the general public. Accepted pull requests are usually merged into the &lt;code&gt;master&lt;/code&gt; branch and closed.&lt;/p&gt;
&lt;p&gt;Other communities are able to leverage bug trackers such as Bugzilla for their development. Various Mozilla projects use their public &lt;a href=&#34;https://bugzilla.mozilla.org/home&#34;&gt;Bugzilla&lt;/a&gt; instance to track issues and ongoing work. Bugzilla can also be used for code review for submitted work.&lt;br&gt;
The Wikimedia Foundation uses &lt;a href=&#34;https://phabricator.wikimedia.org/&#34;&gt;Phabricator&lt;/a&gt; for the same purpose.&lt;/p&gt;
&lt;p&gt;Despite having an active GitHub repository, the Linux kernel&amp;rsquo;s development process does not happen on GitHub. The Linux kernel is unique from most communities in that most of its development happens on mailing lists. Each subsystem will usually have its own mailing list where patches are sent to and reviewed for inclusion into the kernel. Active kernel mailing lists can be found &lt;a href=&#34;http://vger.kernel.org/vger-lists.html&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Version Control&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For remote collaboration, a good version control system is paramount.&lt;br&gt;
Git has become the defacto open source version control software in use, but &lt;a href=&#34;https://www.mercurial-scm.org/&#34;&gt;Mercurial&lt;/a&gt; and &lt;a href=&#34;https://subversion.apache.org/&#34;&gt;Subversion&lt;/a&gt; offer similar functionality. The central Mozilla code &lt;a href=&#34;https://hg.mozilla.org/mozilla-central/&#34;&gt;repository&lt;/a&gt; an example of a large-scale project that uses Mercurial for source and version control.&lt;/p&gt;
&lt;p&gt;Using these tools, patches can be formatted and sent for review in the correct format to enable proper inclusion into the main code base happens.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Code of Conduct&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As the number of people contributing to open source projects grow, certain behavior is expected from contributors to maintain healthy annd civil communities. A code of conduct included in a project is used to describe the expected behavior from the projects&#39; contributors and participants. The code of conduct is usually enforced by project maintainers.&lt;/p&gt;
&lt;p&gt;In 2014, the &lt;a href=&#34;https://www.contributor-covenant.org/&#34;&gt;Contributor Covenant&lt;/a&gt; was released by Coraline Ada Ehmke. Since then, the covenant has been adopted by numerous communities and was even created into a convenient &lt;a href=&#34;https://github.com/ContributorCovenant/contributor_covenant/blob/release/CODE_OF_CONDUCT.md&#34;&gt;template&lt;/a&gt; that can be easily included into new repositories.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Licenses&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each open source project generally has a license included in the source code that explain the rights provided to the user for the software. There are a few popular open source licenses, but all open source licenses typically allow the software to be freely used, modified and shared.&lt;/p&gt;
&lt;p&gt;Popular open source licenses include the GNU General Public License, &lt;a href=&#34;https://opensource.org/licenses/gpl-license&#34;&gt;version 2&lt;/a&gt; and &lt;a href=&#34;https://opensource.org/licenses/GPL-3.0&#34;&gt;version 3&lt;/a&gt; and the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT&lt;/a&gt; license.&lt;br&gt;
The Linux kernel, for example, is licensed under the GNU General Public License v2, with a copy of the license being available in every distribution of the source code.&lt;/p&gt;
&lt;p&gt;To contribute in certain projects, contributors might also be required to sign a Contributor License Agreement (CLA) to give the project the right to include your contribution to the project&amp;rsquo;s code. An example of a project that uses CLAs is React, which usually requires contributors to sign a CLA before their pull request can be accepted.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each open source community will usually have a unique structure depending on its size and function. Contributing to a specific project will often require the identification of how the specific community is managed and how to utilize the aspects described above to become a productive and valuable contributor.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>The Eudyptula Challenge: Task I</title>
       <link>https://www.karuga.org/posts/eudyptula-i/</link>
       <pubDate>Tue, 21 Apr 2020 10:42:05 +0300</pubDate>
       
       <guid>https://www.karuga.org/posts/eudyptula-i/</guid>
       <description>&lt;p&gt;After my initial post introducing the Eudyptula Challenge, this is the first post of my solutions to the challenge. As with every programming tutorial or book, the first task is writing a very simple “hello world” kernel module.&lt;/p&gt;
&lt;p&gt;Here was the description of the first task in the challenge:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write a Linux kernel module, and stand-alone Makefile, that when loaded prints to the kernel debug log level, “Hello World!”.
Be sure to make the module be able to be unloaded as well.&lt;/li&gt;
&lt;li&gt;The Makefile should build the kernel module against the source for the currently running kernel, or, use an environment variable to specify what kernel tree to build it against.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, right off the bat there are a few different concepts from the first task that are unique in kernel programming.
I will mostly be using the Linux Device Drivers book as a reference and the code for my solutions is available on my GitHub – here is the specific solution for this task.&lt;/p&gt;
&lt;h4 id=&#34;loading-and-unloading-kernel-modules&#34;&gt;Loading and Unloading Kernel Modules.&lt;/h4&gt;
&lt;p&gt;The first part of the challenge description requires a kernel module that can be loaded and unloaded into the kernel. This means that the program (module) written can be added into and removed from the kernel at runtime, or during normal operations.
Loading a new kernel module is done by the insmod utility while rmmod unloads the module from the kernel.&lt;/p&gt;
&lt;p&gt;My “hello world” module uses two functions: &lt;code&gt;hello_init&lt;/code&gt; to be called when the module is loaded and &lt;code&gt;hello_exit&lt;/code&gt; to be called when the module is unloaded. Both functions are declared as static as they don’t really have any use outside of this specific file.
This is common for initialization functions in kernel modules as the functions are not meant to be used or visible outside their specific files.&lt;/p&gt;
&lt;p&gt;For the kernel to run the module code, the module must tell the kernel where to find its initialization function. This is done using the &lt;code&gt;module_init&lt;/code&gt; macro which is used to mark the location of the module’s initialization function in its object code.
An initialization function can also be marked using an &lt;code&gt;__init&lt;/code&gt; decorator which tells the kernel that this function will only be used during initialization. Functions with the &lt;code&gt;__init&lt;/code&gt; token are dropped after the module is loaded.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int __init hello_init(void) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For unloading a module, a cleanup function is used to return any allocated resources back to the system. The cleanup function does not have a return value so it’s declared as void. The &lt;code&gt;module_exit&lt;/code&gt; macro points the kernel to a module’s cleanup function – similar to the &lt;code&gt;module_init&lt;/code&gt; macro and the initialization function.
The &lt;code&gt;__exit&lt;/code&gt; modifier can also be used with the module’s cleanup function to indicate that this function will only be used when the module is unloaded.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void __exit hello_exit(void) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Without a cleanup function, the kernel will not allow the module to be unloaded.
The macros used in this section are found in the &lt;code&gt;linux/init.h&lt;/code&gt; header file.&lt;/p&gt;
&lt;p&gt;For printing the challenge’s “Hello World!”, the kernel function printk is used. &lt;code&gt;printk&lt;/code&gt; is similar to printf in C for printing formatted strings in the kernel. printk also uses various log levels that define the priority of the message. From the challenge, our message should have a priority of &lt;code&gt;KERN_DEBUG&lt;/code&gt;, which will make is show up in our dmesg journal.
The various printk priority levels can be found &lt;a href=&#34;https://elinux.org/Debugging_by_printing#Log_Levels&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some other definitions used in kernel code include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MODULE_AUTHOR&lt;/code&gt; which shows who wrote the code.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MODULE_DESCRIPTION&lt;/code&gt; which is a short description of what the module does.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MODULE_LICENSE&lt;/code&gt; which defines the license that the code uses. Using proprietary licenses with this macro usually “taints” the kernel.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These macros are found in the &lt;code&gt;linux/module.h&lt;/code&gt; header file.&lt;/p&gt;
&lt;h4 id=&#34;compiling-the-module&#34;&gt;Compiling the Module.&lt;/h4&gt;
&lt;p&gt;The second part of the challenge requires writing a Makefile that will build the kernel against a kernel source.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Makefile&lt;/code&gt;, in this context is a file with a set of rules passed to the GNU make utility that controls code compilation.
&lt;a href=&#34;https://github.com/wambu-i/eudyptula/blob/master/I/Makefile&#34;&gt;Here&lt;/a&gt; is the Makefile for the “hello world” module.&lt;/p&gt;
&lt;p&gt;When the make command is run, it runs the Makefile. The Makefile first checks if the &lt;code&gt;KERNELRELEASE&lt;/code&gt; variable is set or not. If the variable is set, it indicates that the module is being built by the kernel build system, and can use the kernel’s build language.
In this case, this module will only invoke the following line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj-m := hello.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The kernel build system handles the rest and a module named hello.ko is produced from compilation.&lt;/p&gt;
&lt;p&gt;If the KERNELRELEASE variable is not set, then the Makefile is being invoked from the command line and make will need to be shown where the kernel source is located.This is done using the KERNELDIR variable in the Makefile.
In this case, the following Makefile directive is used to build the kernel.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command starts by changing its directory to the one provided with the -C option where it finds the kernel’s top-level makefile. The M= option causes the kernel’s top-level Makefile to move back into your module source directory before trying to build the modules target. The modules target is the list of modules referred by the obj-m variable in the Makefile.&lt;/p&gt;
&lt;p&gt;After writing both the module and Makefile, my “hello world” module is ready to be compiled:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜ I git:(master) ✗ make
make -C /home/wambui/kernels/staging/ M=/home/wambui/kernels/eudyptula/I modules
make[1]: Entering directory &#39;/home/wambui/kernels/staging&#39;
CC [M] /home/wambui/kernels/eudyptula/I/hello.o
MODPOST 1 modules
CC [M] /home/wambui/kernels/eudyptula/I/hello.mod.o
LD [M] /home/wambui/kernels/eudyptula/I/hello.ko
make[1]: Leaving directory &#39;/home/wambui/kernels/staging&#39;
➜ I git:(master) ✗ ls
hello.c hello.c~ hello.ko hello.mod hello.mod.c hello.mod.o hello.o Makefile modules.order Module.symvers
➜ I git:(master) ✗
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After successful compilation, the module can then be loaded and unloaded:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[wambui I]# ls
hello.c hello.c~ hello.ko hello.mod hello.mod.c hello.mod.o hello.o Makefile modules.order Module.symvers
[wambui I]# insmod ./hello.ko
Hello, World!
[wambui I]# #rmmod hello
I&#39;m going...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And with that, the first challenge is done!&lt;/p&gt;
&lt;p&gt;In general, there are three different types of kernel modules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A character/char module that provides a device that can be accessed as a stream of bytes. These devices live in the /dev/ folder on the filesystem.&lt;/li&gt;
&lt;li&gt;A block device module that implements a block device that can also be found in the /dev/ folder. Block devices are devices that can hold a filesystem and can perform input/output transfers of whole blocks of data.&lt;/li&gt;
&lt;li&gt;A network device module that implements and controls a hardware or software network interface at the kernel level.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My “hello world” module does not fall into any of these categories, but it’s a great start on writing kernel modules!
I’m looking forward to continuing with the challenge where I can build on top of the concepts learnt here.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>The Eudyptula Challenge</title>
       <link>https://www.karuga.org/posts/eudyptula-challenge/</link>
       <pubDate>Sat, 18 Apr 2020 10:39:42 +0300</pubDate>
       
       <guid>https://www.karuga.org/posts/eudyptula-challenge/</guid>
       <description>&lt;p&gt;The Free and Open Source Software movement has existed since the 1980s with Richard Stallman being credited as the “father” of the free and open source movement. Throughout the years, FOSS has gained momentum and popularity in the technology world with many developers and advocates hailing it as the future standard of technology. However, there are also two different positions covered under the umbrella term “FOSS”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Free software which gives the user the power/ability to run, change and distribute the software as they see fit. It should be noted here that “free” does not refer to the price of the software but rather the rights and liberties the user of the software has. This position is based on trying to protect and guarantee a user’s essential freedoms and liberties.&lt;/li&gt;
&lt;li&gt;Open source software which is usually governed by different licenses that allow the redistribution and editing of software released to the public. The source code of open source projects is publicly available for inspection, enhancement and modification.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Linux Kernel is probably the largest and well known free and open source software. It was originally created in 1991 by Linus Torvalds with the source code being both free and open source. The use of the Linux kernel as the operating system of choice in most aspects of computing has (in my opinion) been one of the main drivers of the adoption of the open source development model. The ability to customize and use your operating system however you see fit is one of the main reasons that the Linux kernel and Linux-based distributions are so popular.&lt;/p&gt;
&lt;p&gt;For a while now, I’ve been looking into ways on how to get started in contributing to the Linux kernel. As a developer, I’d tried to contribute to several different open source projects, but I kept being drawn back to the Linux kernel. I’d spend whole days going through documentation and articles on how to start working on the kernel but I could never make the leap to actual contributions.&lt;br&gt;
One of the main challenges was that the Linux kernel is huge – with millions of lines of code in the main code base. I had so many ideas of what I was interested in and which parts of the kernel I wanted to contribute to that I could not figure out where to start.&lt;br&gt;
The kernel also has a unique contribution and development model that is daunting to kernel beginners. There are also literally thousands of developers from around the world actively developing and maintaining it.&lt;br&gt;
Fun fact, the GitHub repository of the Linux kernel indicates that it has infinity collaborators:
Linux Kernel Contributors&lt;/p&gt;
&lt;p&gt;It wasn’t until I took part in the Outreachy programme that I finally got to contribute to the Linux kernel. During this period, I also found out about the Eudyptula Challenge which was described as “a series of programming exercises for the Linux kernel, that started from a very basic ‘Hello world’ kernel module, moving on up in complexity to getting patches accepted into the main Linux kernel source tree.”&lt;/p&gt;
&lt;p&gt;The Eudyptula Challenge, unfortunately, has not been active 2017, but the exercises used in the challenge can be easily found from people who have attempted it. After reading through the Linux Device Drivers book during my internship, I’m hoping to practice what I learnt by attempting the Eudyptula Challenge. This series will therefore try to document and explain my progress as I make my way through the challenge exercises. So here’s to hoping I’ll do and write about all twenty of the exercises!&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Outreachy: Applying and Getting Accepted into the Programme.</title>
       <link>https://www.karuga.org/posts/outreachy-1/</link>
       <pubDate>Tue, 31 Dec 2019 10:20:50 +0300</pubDate>
       
       <guid>https://www.karuga.org/posts/outreachy-1/</guid>
       <description>&lt;p&gt;I found out about the Outreachy internship project in 2018 during my last year of school. I was interested in getting involved in contributing to the open source community and the Outreachy program kept popping up in guides on how beginners could get started in the open source world. Outreachy is an internship program that matches interns with Free and Open Source Software communities for a three month contribution period.&lt;/p&gt;
&lt;p&gt;I didn&amp;rsquo;t get to apply for the program in 2018 - partly due to my school workload and partly because I was afraid of not passing through the application period. I had previously applied to and been rejected by Google Summer of Code, so I was sure that I&amp;rsquo;d be getting rejection again.&lt;/p&gt;
&lt;p&gt;It wasn&amp;rsquo;t until late in 2019 when I revisited the idea of applying to Outreachy again. The December 2019 - March 2020 internship applications were open and at that point, I had been employed full time as a software engineer. Over the past year, I&amp;rsquo;d slowly started getting involved with the open source world by contributing to the Mozilla Foundation, both in code contributions and getting involved in their Internet Health initiatives.&lt;/p&gt;
&lt;p&gt;Through my job, I&amp;rsquo;d gotten interested in kernel and operating systems development and was very excited that some of the projects in this round were contributing to the Linux Kernel. I&amp;rsquo;m a very poor applicant so I waited until the last day to fill in the first application form (not recommended), and a week later, I got an email that I&amp;rsquo;d passed the first application round!&lt;/p&gt;
&lt;p&gt;For me, the contribution period was a bit more challenging. The Linux kernel has a separate tutorial for interns wishing to contribute to the project. Interns would need to submit a series of patches on the &lt;!-- raw HTML omitted --&gt;staging&lt;!-- raw HTML omitted --&gt; branch of the kernel to practice on how to get patches in the kernel accepted and merged. Submitting my first patches was very nerve-wracking - I think I went through the tutorial five times before I could send my first (trivial) patch - but &lt;a href=&#34;https://en.wikipedia.org/wiki/Greg_Kroah-Hartman&#34;&gt;Greg Kroah-Hartman&lt;/a&gt; and &lt;a href=&#34;https://pages.lip6.fr/Julia.Lawall&#34;&gt;Julia Lawall&lt;/a&gt; were very helpful in reviewing patches submitted.&lt;/p&gt;
&lt;p&gt;One of the experiences that helped me during my application was attending the Embedded Linux Conference - Europe at the end of October 2019. I was able to meet and talk to the previous Outreachy interns about their experiences during the application period and their internships. I was also able to meet one of my current mentor - Daniel Vetter - during the conference.&lt;/p&gt;
&lt;p&gt;I got my acceptance as an intern four weeks after my application round, and I&amp;rsquo;m now officially and intern with the Linux Kernel GPU subsystem! I recently started my internship and I couldn&amp;rsquo;t be happier that I stuck with the application process. I still get excited seeing my name in the commit log - especially in a project as universal and loved as the Linux kernel.&lt;/p&gt;
&lt;p&gt;One of the things that I reflect on about my application process is the self doubt I experienced. Two weeks into my internship, I&amp;rsquo;m very happy that I didn&amp;rsquo;t talk myself out of applying due to it.&lt;/p&gt;
</description>
     </item>
   
 </channel>
</rss>
